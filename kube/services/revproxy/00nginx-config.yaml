#
# Note: apply this file via apply_config to fill in the DNS
#   resolver required for cookie-based routing to canary/test services
#
apiVersion: v1
kind: ConfigMap
metadata:
  name: revproxy-nginx-conf
data:
  userid.js: |
      /** global supporting atob polyfill below */
      var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

      /**
       * base64 decode polyfill from
       *     https://github.com/davidchambers/Base64.js/blob/master/base64.js
       */
      function atob(input) {
        var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=
        if (str.length % 4 == 1) {
          return input;
        }
        for (
          // initialize result and counters
          var bc = 0, bs, buffer, idx = 0, output = '';
          // get next character
          buffer = str.charAt(idx++);
          // character found in table? initialize bit storage and add its ascii value;
          ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
        ) {
          // try to find character in table (0-63, not found => -1)
          buffer = chars.indexOf(buffer);
        }
        return output;
      }

      /**
       * nginscript helper for parsing user out of JWT tokens.
       * We appear to have access to the 'access_token' variable
       * defined in nginx.conf when this function runs via 'js_set'.
       * see https://www.nginx.com/blog/introduction-nginscript/
       *
       * @param {*} req
       * @param {*} res
       */
      function userid(req, res) {
        var token = req.variables["access_token"];
        var user = "uid:null,unknown@unknown";

        if (token) {
          user = token;
          var raw = atob((token.split('.')[1] || "").replace('-', '+').replace('_', '/'));
          if (raw) {
            try {
              var data = JSON.parse(raw);
              if (data) {
                if (data.context && data.context.user && data.context.user.name) {
                  user = "uid:" + data.sub + "," + data.context.user.name;
                }
              }
            } catch (err) {}
          }
        }
        return user;
      }

      /**
       * returns absolute value of a number
       */
      function MathAbs(x) {
        x = +x;
        return (x > 0) ? x : 0 - x;
      }

      /**
       * util for hasing a string into given range
       *
       * @param s - string to hash
       * @param size - range to hash into
       */
      function simpleHash(s, size) {
        var i, hash = 0;
        for (i = 0; i < s.length; i++) {
          hash += (s[i].charCodeAt() * (i+1));
        }
        return MathAbs(hash) % size;
      }

      /*
       * Checks cookie for service release versions and assigns
       *   release versions for services not in the cookie based
       *   on hash value and the percent weight of the canary.
       * Returns a string of service assignments. E.g:
       *   "fence:canary;sheepdog:production;"
       *
       * @param req - nginx request object
       */
      function getServiceReleases(req) {

        var release_cookie = req.variables['cookie_release_tags'];
        var services = ['fence', 'sheepdog'];

        // hash user info to select the release
        var hash_str = ['app', req.variables['realip'], req.variables['http_user_agent'], req.variables['date_gmt']].join();
        var hash_res = simpleHash(hash_str, 100);
        var canary_percent = 10;
        var selected_release = 'production';
        if (hash_res < canary_percent) {
          selected_release = 'canary';
        }
        // if not given a release for a service, use the one selected by hash
        /*
        var updated_release_cookie = services.map(function(name) {
          var release_val = release_cookie.match(name+'\.(production|canary)')
          if (!release_val) {
            return name + '.' + selected_release;
          }
          return release_val[0];
        })
          .join('&');
        */
        var updated_release = "";
        for (var i=0; i < services.length; i++) {
          var release_val = release_cookie.match(name+'\.(production|canary)')
          if (!release_val) {
            updated_release = updated_release + name + '.' + selected_release + "&";
          } else {
            updated_release = updated_release + release_val[0] + "&";
          }
        }

        // req.headersOut.release_tags = updated_release_cookie

        // return updated_release_cookie
        return updated_release
      }

  nginx.conf: |
      user nginx;
      worker_processes 4;

      pid /var/run/nginx.pid;

      load_module modules/ngx_http_perl_module.so;

      env POD_NAMESPACE;

      events {
      	worker_connections 768;
      	# multi_accept on;
      }

      http {

      	##
      	# Basic Settings
      	##
      	sendfile on;
      	tcp_nopush on;
      	tcp_nodelay on;
      	keepalive_timeout 65;
      	types_hash_max_size 2048;
        port_in_redirect off;
      	# server_tokens off;

        # For websockets
        map $http_upgrade $connection_upgrade {
          default upgrade;
          ''      close;
        }

        map $proxy_protocol_addr $initialip {
          "" $http_x_forwarded_for;
          default $proxy_protocol_addr;
        }

        map $initialip $realip {
          "" $remote_addr; #if this header missing set remote_addr as real ip
          default $initialip;
        }

      	# server_names_hash_bucket_size 64;
      	# server_name_in_redirect off;

        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        ##
        # Note - nginscript js_set, etc get processed
        #   on demand: https://www.nginx.com/blog/introduction-nginscript/
        #
        js_include userid.js;
        js_set $userid userid;

        #        #
        #        # Split traffic to production and canary
        #        # See https://www.viget.com/articles/split-test-traffic-distribution-with-nginx/
        #
        #        # The "$fence_variant" variable is set to different value
        #        # depending on random hash
        #        split_clients "app${realip}${http_user_agent}${date_gmt}" $fence_variant {
        #          10% "canary"; # 10% of addresses assigned to canary
        #          * "production"; # 90% of addresses assigned to production
        #        }
        #
        #        # map cookie type to the release version
        #        # if cookie does not exist, assign to the generated variant
        #        map $cookie_fence_release $fence_release {
        #          default $fence_variant;
        #          "canary" "canary";
        #          "production" "production";
        #        }
        #
        #        # map fence release version to deployment name
        #        map $fence_release $fence_deploy_name {
        #          "canary" "fence-canary";
        #          "production" "fence";
        #        }

        #
        # service assignment
        #
        js_set $service_releases getServiceReleases;

      	##
      	# Logging Settings
      	##
        log_format aws   '$realip - $userid [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" '
                    '"$service_releases"';
      	access_log /dev/stdout aws;
      	error_log /dev/stderr;

      	##
      	# Gzip Settings
      	##
        gzip on;
        gzip_disable "msie6";
        gzip_proxied any;
        gzip_types
          text/css
          text/javascript
          text/xml
          text/plain
          application/javascript
          application/x-javascript
          application/json;

        ##
        # Namespace
        ##
        perl_set $namespace 'sub { return $ENV{"POD_NAMESPACE"}; }';

        ##
        # Upstream servers
        #
        # Direct to -service and -canary deployments
        # Inspects <service_name>_srv_id cookie value to select server
        # See http://nginx.org/en/docs/http/ngx_http_upstream_module.html#sticky
        ##
        perl_set $kubernetes_hostname "$namespace.svc.cluster.local";
        perl_set $service_weight 9;

        #        upstream fence_pool {
        #          server fence-service.$kube_hostname weight=3;
        #          server fence-canary-service.$kube_hostname;
        #        }

        #        upstream fence2_pool {
        #          server fence-service.$kube_hostname/user/anyaccess route=production weight=$service_weight;
        #          server fence-canary-service.$kube_hostname/user/anyaccess route=canary;
        #
        #          sticky cookie fence2_srv_id
        #        }

        ##
      	# Proxy Settings
      	##
        # Serve internet facing http requests via this, and redirect to https
        server {
          listen      82 default_server proxy_protocol;
          listen      83;
          rewrite     ^   https://$host$request_uri? permanent;
        }
        # Serve internet facing https requests and internal http requests here
      	server {
          listen 81 proxy_protocol;
          listen 80;
          listen 443 ssl;

          ssl_certificate     /mnt/ssl/external.crt;
          ssl_certificate_key /mnt/ssl/external.key;
          ssl_protocols       TLSv1.1 TLSv1.2;
          ssl_ciphers         HIGH:!aNULL:!MD5;

      	  server_tokens off;
          more_set_headers "Server: gen3"
      	  more_set_headers "Strict-Transport-Security: max-age=63072000; includeSubdomains; preload";
          more_set_headers "X-Frame-Options: SAMEORIGIN";
          more_set_headers "X-Content-Type-Options: nosniff";

          if ($http_x_forwarded_proto = "http") { return 301 https://$host$request_uri; }
          
          #
          # From https://enable-cors.org/server_nginx.html
          # This overrides the individual services
          #
          set $allow_origin "*";
          if ($http_origin) {
            set $allow_origin "$http_origin";
          }

          more_set_headers "Access-Control-Allow-Origin: $allow_origin";
          more_set_headers "Access-Control-Allow-Methods: GET, POST, OPTIONS";
          more_set_headers "Access-Control-Allow-Credentials: true";
          more_set_headers "Access-Control-Allow-Headers: DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,Cookie,X-CSRF-Token";
          more_set_headers "Access-Control-Expose-Headers: Content-Length,Content-Range";

          if ($request_method = 'OPTIONS') {
            return 204;
          }
          #
          # DNS resolver required to resolve dynamic hostnames, btw - kubedns may not support ipv6
          # see https://www.nginx.com/blog/dns-service-discovery-nginx-plus/
          #     https://distinctplace.com/2017/04/19/nginx-resolver-explained/
          #
          resolver kube-dns.kube-system.svc.cluster.local ipv6=off;

          set $access_token "";
          set $csrf_check "ok-tokenauth";

          #
          # Note: add_header blocks are inheritted iff the current block does not call add_header:
          #     http://nginx.org/en/docs/http/ngx_http_headers_module.html
          #
          set $csrf_token "$request_id$request_length$request_time$time_iso8601";
          if ($cookie_csrftoken) {
            set $csrf_token "$cookie_csrftoken";
          }
          add_header Set-Cookie "csrftoken=$csrf_token;Path=/";
          
          if ($cookie_access_token) {
              set $access_token "bearer $cookie_access_token";
              # cookie auth requires csrf check
              set $csrf_check "fail";
          }
          if ($http_authorization) {
              # Authorization header is present - prefer that token over cookie token
              set $access_token "$http_authorization";
          }

          #
          # Note - need to repeat this line in location blocks that call proxy_set_header,
          #   as nginx proxy module inherits proxy_set_header if and only if current level does
          #   not set headers ... http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header
          #
          proxy_set_header   Authorization "$access_token";
          proxy_set_header   Host $host;
          proxy_set_header   X-Forwarded-For "$realip";
          proxy_set_header   X-UserId "$userid";

          #
          # CSRF check
          # This block requires a csrftoken for all POST requests.
          #
          if ($cookie_csrftoken = $http_x_csrf_token) {
            # this will fail further below if cookie_csrftoken is empty
            set $csrf_check "ok-$cookie_csrftoken";
          }
          if ($request_method != "POST") {
            set $csrf_check "ok-$request_method";
          }
          if ($cookie_access_token = "") {
            # do this again here b/c empty cookie_csrftoken == empty http_x_csrf_token - ugh
            set $csrf_check "ok-tokenauth";
          }

          include /etc/nginx/gen3.conf/*.conf;

          location @error401 {
              return 302 /login;
          }
      	}
      }
